---
title: Immutable Collections Library for Javascript: The Paper
---

<head>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<link rel="stylesheet" href="http://mads379.github.com/bachelorproject/css/screen.css" type="text/css" media="screen" title="no title" charset="utf-8">	
	<!-- <link rel="stylesheet" href="file:///Users/Mads/dev/projects/bachelorproject/css/screen.css" type="text/css" media="screen" title="no title" charset="utf-8"> -->
</head>


<h1 class="header">Immutable Collections Library for Javascript <br /> <em>The Paper</em></h1>
<ol id="menu">
	<li>"About":http://mads379.github.com/bachelorproject</li>
	<li>"The API":http://mads379.github.com/bachelorproject/api</li>
	<li>The Paper</li>
</ol>
<div id="container">

h2(#table_of_contents). Table of Contents 

# "Preface and introduction":#preface_and_introduction
# "Background and description of the problem":#background_and_description_of_the_problem
## "Problem Definition":#problem_definition
## "Design goals":#design_goals
## "Overview of collections":#overview_of_collections
## "Comparison with other collection libraries":#comparison_with_other_collections
## "Coffeescript":#coffeescript
# "Problem analysis":#problem_analysis
## "Equality and Comparison":#equality_and_comparison
## "Handling Operations That Might Fail":#handling_operations_that_might_fail
## "Implemented Data Types":#implemented_data_types
# "Userâ€™s guide and examples":#users_guide_and_examples
# "Technical description of the program":#technical_description_of_the_program
## "Javascript call-stack":#javascript_call_stack
## "Object construction":#object_construction
# "Test":#test
# "Conclusion":#conclusion
# "References":#references

h2(#preface_and_introduction). Preface and introduction

This report has been written by Mads Hartmann Jensen in the months February to May at the IT University of Copenhagen under the supervision of "Peter Sestoft":http://www.itu.dk/people/sestoft/.

During the project I developed an immutable collections library for Javascript written in the programming language Coffeescript.

h2(#background_and_description_of_the_problem). Background and description of the problem

h3(#problem_definition). Problem Definition

Javascript is a widely used programming language and it is used to implement countless of web applications. Despite of its popularity javascript has a very limited collections library which only contains one data-structure: An array which can function as a regular array, a stack, and a dictionary all at the same time. 
This has lead to the development of a range of open-source collection libraries such as Google Closure[1] and js_cols[2].

However, the current collection libraries available focus on mutable collections which are implemented using destructive updates. As such the goal of this project is to create a powerful set of immutable collection prototypes that will make it more natural to write javascript programs in a functional manner using features like higher-order functions. 

The library will be written in Coffeescript[3], a small language that compiles to JavaScript, as it adds a few semantics that will help simplify the code.

The project will include a set of performance tests that evaluate the data-structures on different implementations of javascript to make sure the performance of the data-structures are not subject to the implementation details of a specific javascript machine.

h3(#design_goals). Design goals

The overall goal is to create a powerful set of immutable collection prototypes for Javascript that promotes the use of functional javascript. The collection prototypes should feel natural to a developer coming from a functional programming language such as Scala.

The concrete goals of the project are:
# All the collection prototypes should be immutable.
# Provide a collection prototype library for Javascript that will feel natural to programmers coming from other functional programming languages.
# Provide an implementation of the most basic abstract data types (List, Set, Map, Queue).
# The code should be tested enough that potential users feel comfortable using the library.
# The collection library should be usable in the browser and server-side by, for example, NodeJS.
# To document the asymptotic run-time complexity of all implementations.

h3(#overview_of_collections). Overview of collections

Even though Javascript, being the dynamic language that it is, doesn't have interfaces I've made sure that there is a set of methods that are supported by all collection prototypes. Each collection must implement these methods and is free to add any additional methods specific to that abstract data types. 

The library contains an implementation of the following abstract data types:

# List 
# Set 
# Map 
# MultiMap
# Stack
# Queue 
# Random Access List
# Priority Queue

h3(#comparison_with_other_collections). Comparison with other collection libraries

This section will compare this library with the Google Closure Library and attempt to justify the creation of a new library.

The *Google Closure Library* is a comprehensive library that contains the implementation of of several data structures (AVL trees, Heaps, Maps, QuadTrees, Queues, Sets, TrieTrees and more). The library serves as the base Javascript library for many Google products, including: Gmail, Maps, Docs, Books and more. The library is open source and is actively being developed on by Google. Being used in production by Google also means that the library is well tested and well supported. 

However, all of the data structures in the Google Closure Library are mutable and their operations rely on destructive updates. There are currently no immutable collection libraries available for javascript that I'm aware of, hence the creation of this library. 

Ideally functional programs are side effect free, that means that functions can have no other effect than to compute their result. Programming with pure functions makes it a lot easier to reason about the state of your program. Having an immutable collections library makes it possible to keep your functions pure. 

The importance of immutability has also been established by Joshua Bloch in his book Effective Java as the 15th item "Minimize Mutability".

h3(#coffeescript). Coffeescript

Coffeescript is a small language that compiles to javascript. The output of the compiler is readable, pretty printed, javascript that passes the "Javascript Lint tool":http://www.javascriptlint.com/index.htm without warnings. Coffeescript is a dialect of Javascript with a simpler, more lightweight syntax. That is to say that it doesn't introduce any new concepts and it sticks to the original Javascript object model which uses prototypal inheritance. 

The two main reasons I've chosen to write this library in Coffeescript is that it has a nice syntax for function literals, which is important when you're writing your programs in a functional style, and is uses the convention that the last expression is used as the return value of a function. 

Here's a couple of Coffeescript examples and the resulting Javascript outputted by the compiler. The goal of these examples is to show the simplicity of Coffeescript and the readability of output. For a extensive description of the entire language, please go to the "Coffeescript homepage":http://jashkenas.github.com/coffee-script/ for more information

<table>
	<thead>
	<tr>
		<td width="40%">*Coffeescript*</td>
		<td width="40%">*Javascript*</td>
	</tr>
	</thead>
	<tr>
		<td><pre><code>(x,y) -> x+y</code></pre></td>
		<td><pre><code>(function(x, y) {    
  return x + y;    
});</code></pre></td>
	</tr>
	<tr>
		<td>
			<pre><code>Nil = () ->    
  this.head    = new None()    
  this.tail    = new None()    
  this.isEmpty = () -> true    
  this</code></pre>
		</td>
		<td><pre><code>var Nil;    
Nil = function() {    
  this.head = new None();    
  this.tail = new None();    
  this.isEmpty = function() {    
    return true;    
  };    
  return this;    
};</code></pre></td>
	</tr>
</table>

At the time of writing the version of Coffeescript is 1.0.1 and it is the version that's used in this report.

h2(#problem_analysis). Problem analysis

TODO

h3(#equality_and_comparison). Equality and comparison

TODO

h3(#handling_operations_that_might_fail). Handling Operations That Might Fail

This section explains how the library deals with methods where a successful result isn't guaranteed. An example of this could be the @get(key)@ method on Map. In cases like this I've chosen to return an instance of Option rather than null or throwing an exception. Instances of Option are either an instance of the type of Some or None. Some is a single element container which contains the result of successfully executing the method. The use of the Option type is adopted from the Scala standard library. Readers coming from a functional programming background might recognize Option as a Monad.

To display the power of Option I've created three applications that will get a value from a Map and use that value to receive a second value from another map and finally print that value to the console. The first solutions takes an imperative approach to the problem and assumes that the get() method on Map will return null if the key doesn't exist. This is similar to the Map class in the standard Java collection. The second solution assumes that the @get()@ method throws an exception if the key isn't present in the Map. The final solution takes a functional approach and the @get()@ method on Map returns an Option. All of the examples have been implemented using Coffeescript. 

All of the solutions assume that the following two maps are declared.

<pre><code>persons = new Map({ key: 'Mads', value: 1234 })
details = new Map({ key: 1234, value: { address: 'Grundtvigs Sidevej 1 st th' } })</code></pre>

The following is the application that relies on null:

<pre><code>address = null;
madsId = persons.get("Mads")
if (madsId != null) {
	madsDetails = details.get(madsId)
	if (madsDetails != null) {
		address = madsDetails.address
	}
}
if (address != null) {
	console.log(address)
} else {
	console.log("No address for user")
}</code></pre>

The following is the application that relies on exceptions:

<pre><code>try {
	madsId = persons.get("Mads"),
	madsDetails = defailts.get(madsId)
	address = madsDetails.address
	console.log(address);
} catch(e) {
	console.log("No address for user")
}</code></pre>

The following is the functional solution:

<pre><code>address = persons.get("Mads").map( (id) -> details.get(id) ).map( (obj) -> obj.address )
console.log(address.getOrElse("No address for user"))</code></pre>

The example that assumes the @get()@ method returns an Option is clearly the shortest but Option also has other advantages over null or exceptions. These advantages are easiest to express by explaining the disadvantages of using null or exceptions.

Both exceptions and null share the common disadvantage that the developer is free to ignore the possibility of an error when invoking a method. This may be intentional or by mistake as the only way to figure out if a method has the possibility of throwing an error or return null is by reading the source code or documentation. When using Option the developer is *always* forced to consider the possibility of an error as it isn't possible to access the values directly. Because javascript isn't statically typed the developer would still have to run the program at least once to discover that an option was returner rather than the actual value but this is still better than null/exceptions where the developer would have to run the program in such a way that would invoke the error before realizing the possibility of an error. 

When methods return null you always have to check if a value is null before using it in subsequent expressions. This will clutter the programs with a lot of @if( value != null ) { }@ statements which hide the true intent of the program. When using Option you can chain operations without having to check for the existence of a value before the very last expression where the developer can supply a fallback value using the @getOrElse()@ method. This is done using the @map@, @flatMap@, @filter@ and @foreach@ methods. This results in code that is shorter and more concise as the above example show. It is possible to chain operations on Option due to the fact that all operations on @None@ return @None@ except for @getOrElse(value)@ which return the value. @getOrElse(value)@ on @Some@ will return the element stored in the container and ignore @value@.

To summarize, the advantages of using Option rather than null or exceptions are: 

# Earlier recognition of possible errors.
# Operations are chain-able.
# Results in shorter and more concise code.

h3(#implemented_data_types). Implemented Data Types

The following abstract data types have have been implemented: List, Set, Queue, Map, MultiMap, Stack. Some abstract data types have more than one implementation based on different data structures that offer different running time complexities of their operations. This allows the developer to pick the implementation that fits his/her needs. This section will describe each abstract data types and their implementations. 

<center>
	<img src="images/prototype-chain.png" width="567" height="341" alt="Prototype Chain" />
</center>

Though the abstract data types are different in many ways they all support the same subset of operations. The most important operations are described below. For a full list of operations on each data type see the API documentation. 

In the following table the complexities are expressed in terms of n or n' where n is the size of the original collection and n' is the size of the resulting collection.

<table>
	<thead>
	<tr>
		<td width="140px">*Name*</td>
		<td>*Description*</td>
		<td width="50px">*Complexity*</td>
	</tr>
	</thead>
	<tr>
		<td>map( f )</td>
		<td>Applies the function 'f' on each element in the collection and returns a new collection with the values returned from applying the function 'f'.</td>
		<td>@O(N)@</td>
	</tr>
	<tr>
		<td>flatMap( f )</td>
		<td>Applies the function 'f' to all elements of the collection and concatenates the results.</td>
		<td>@O(n)@</td>
	</tr>
	<tr>
		<td>filter( f )</td>
		<td>Applies the function 'f' on each element and returns a collection of the same type with the elements where the function returned true.</td>
		<td>@O(n)@</td>
	</tr>
	<tr>
		<td>forEach( f )</td>
		<td>Applies the function f on each element in the collection and returns nothing. This means that forEach is invoked for the side effects of f.</td>
		<td>@O(n')@</td>
	</tr>
	<tr>
		<td>foldLeft( seed )( f )</td>
		<td>Applies the binary function 'f' on each element in the list starting from left. The function 'f' takes two arguments: The first is the accumulation of applying the function f on the elements of the collection so far. The second is the current value. </td>
		<td>@O(n)@</td>
	</tr>
</table>

h4(#list). List

Lists are ubiquitous in functional programming languages. A List contains a sequence of elements in the order they were inserted. A list consists of either Cons or Nil. Cons contains an element and a reference to the rest of the list. Nil represents the empty list. This is also sometimes known as a Singly-Linked-list.

The following operations are specific to the List abstract data type.

<table>
	<thead>
	<tr>
		<td width="140px">*Name*</td>
		<td>*Description*</td>
		<td width="50px">*Complexity*</td>
	</tr>
	</thead>
	<tr>
		<td>append( element )</td>
		<td>Create a new list by appending the element</td>
		<td>@O(n)@</td>
	</tr>
	<tr>
		<td>prepend( element )</td>
		<td>Create a new list by prepending the element</td>
		<td>@O(1)@</td>
	</tr>
	<tr>
		<td>update( index, element)</td>
		<td>Update the value with index 'index'. This will copy all values up to the given index.</td>
		<td>@O(n)@</td>
	</tr>
	<tr>
		<td>get( index )</td>
		<td>Get the element stored with the given index</td>
		<td>@O(n)@</td>
	</tr>
	<tr>
		<td>remove( index )</td>
		<td>Removes the element stored at the given index</td>
		<td>@O(n)@</td>
	</tr>
</table>
	

h4(#set). Set

Set contains a sequence of elements. The Set has the property that no element may appear twice. The library contains two implementations of Set: One based on a tree and one based on hashing.

h5(#tree_based_set). Tree Based Set

The TreeSet is implemented using a Red Black Tree which is a balanced tree with invariants to keep the height of the tree as low as possible. Here's the table of operations and their complexities supported by the tree-based set. 

<table>
	<thead>
	<tr>
		<td width="140px">*Name*</td>
		<td>*Description*</td>
		<td width="50px">*Complexity*</td>
	</tr>
	</thead>
	<tr>
		<td>insert( element )</td>
		<td>Adds the element to the set</td>
		<td>@O(log n)@</td>
	</tr>
	<tr>
		<td>update( index, element)</td>
		<td>Update the value with index 'index'. This will copy all values up to the given index.</td>
		<td>@O(log n)@</td>
	</tr>
	<tr>
		<td>get( index )</td>
		<td>Get the element stored with the given index</td>
		<td>@O(log n)@</td>
	</tr>
	<tr>
		<td>remove( index )</td>
		<td>Removes the element stored at the given index</td>
		<td>@O(log n)@</td>
	</tr>
</table>

h5(#hash_based_set). Hash Based Set

TODO

h4(#stack). Stack

A stack inserts and retrieves elements according to the last-in-first-out (LIFO) principle. The Stack Abstract Data Type has been implemented using a List because of it's quick access, insertion and removal of the first element. 

<table>
	<thead>
	<tr>
		<td width="140px">*Name*</td>
		<td>*Description*</td>
		<td width="50px">*Complexity*</td>
	</tr>
	</thead>
	<tr>
		<td>pop()</td>
		<td>Removes the top element form the stack</td>
		<td>@O(1)@</td>
	</tr>
	<tr>
		<td>push( element )</td>
		<td>Adds the 'element' to the top of the stack</td>
		<td>@O(1)@</td>
	</tr>
	<tr>
		<td>top()</td>
		<td>Returns the top element of the stack</td>
		<td>@O(1)@</td>
	</tr>
</table>

h4(#queue). Queue

A queue inserts and retrieves elements according to the first-in-first-out (FIFO) principle. The Queue Abstract Data Type has been implemented using a .... not sure yet ....

<table>
	<thead>
	<tr>
		<td width="140px">*Name*</td>
		<td>*Description*</td>
		<td width="50px">*Complexity*</td>
	</tr>
	</thead>
	<tr>
		<td>enqueue()</td>
		<td>Adds a new element to the queue</td>
		<td>@?@</td>
	</tr>
	<tr>
		<td>dequeue( element )</td>
		<td>Removes the next element in the queue</td>
		<td>@?@</td>
	</tr>
	<tr>
		<td>front()</td>
		<td>Returns the front-most element of the stack</td>
		<td>@?@</td>
	</tr>
</table>

h4(#map). Map 

A map stores elements according to a given key. The library contains two implementations of Map: One based on a tree and one based on hashing.

h5(#tree_based_map). Tree Based Map

The TreeMap is implemented using a Red Black Tree which is a balanced tree with invariants to keep the height of the tree as low as possible. Here's the table of operations and their complexities supported by the tree-based map. 

<table>
	<thead>
	<tr>
		<td width="140px">*Name*</td>
		<td>*Description*</td>
		<td width="50px">*Complexity*</td>
	</tr>
	</thead>
	<tr>
		<td>insert( key, value)</td>
		<td>Adds a new key/value pair to the map</td>
		<td>@O(log n)@</td>
	</tr>
	<tr>
		<td>get( key )</td>
		<td>Returns the element associated with the given key</td>
		<td>@O(log n)@</td>
	</tr>
	<tr>
		<td>remove( key )</td>
		<td>Removes the key/value pair from the map</td>
		<td>@O(log n)@</td>
	</tr>
	<tr>
		<td>contains( key )</td>
		<td>Checks if the map contains the given key</td>
		<td>@O(log n)@</td>
	</tr>
</table>

h5(#hash_based_map). Hash Based Map

TODO 

h4(#multi_map). Multi Map

TODO

h5(#tree_based_multimap). Tree Based Multi Map

TODO 

h2(#users_guide_and_examples). Userâ€™s guide and examples

Explain how to start using the library in the browser and NodeJS. Show some example programs and explain how they work.

If I have the time it would be cool to implement one or two of the problems in "Pearls of Functional algorithm design" or Exercise 12.8 in Algorithms and data structures - the basic toolbox 

h2(#technical_description_of_the_program). Technical description of the program

h3(#object_construction). Object construction

There are many different ways to create and initialize a new object in javascript and each one comes with its own set of merits and penalties. In this section I will describe three different ways to construct objects in javascript and explain which one I've chosen for this library and why. The three approaches are explained in depth in Douglas Crockford's book JavaScript: The Good Parts. 

h4(#factory_functions). Functional

In the Functional approach you create a function which acts as the constructor for the object you want to create. It can take any number of arguments and it uses those arguments to add properties and methods to the object. The example below shows a Person function which takes two arguments: firstName, lastName. It uses those arguments to create two properties and a method on the object.

<pre><code>var Person = function(firstName, lastName){
	this.firstName = firstName;
	this.lastName  = lastName;
	this.fullName = function(){ return this.firstName + " " + this.lastName; };
	return this; 
};

new Person("Mads","Hartmann");</code></pre>

The advantage of this approach is that you can define any variables you want inside of the function and they will act as private members. The disadvantage is that instances created with this function will be heavy objects in the sense that all of them will store the code for each method. 

h4(#prototype). Pseudoclassical  

In the Pseudoclassical approach you create a function which only initializes the properties of the object. Instead of adding the methods directly on each object you add it to the prototype as shown below. 

<pre><code>var Person = function(firstName, lastName){
	this.firstName = firstName;
	this.lastName  = lastName;
	return this; 
};

Person.prototype.fullName = function(){ return this.firstName + " " + this.lastName; };

new Person("Mads","Hartmann");</code></pre>

This resolves the disadvantage of the Functional approach as all the instances share the same prototype object. This means that object creation is roughly 3 x faster (see section about performance tests) because the interpreter doesn't need to add the same methods to all of the objects. This also results in objects that use less memory.

There are two disadvantages to this approach. Firstly, because the methods are no longer stored directly on the object the interpreter needs to do one extra lookup before it can execute the method. Because of this it takes roughly %40 longer to invoke a method on an object. The second disadvantage is that it's no longer possible for the objects to have any private state. 

h4(#object_create). Prototypal

The ECMAScript 5 Language Specification defines a new method on Object: Object.create. Given an object and a properties object it will create a new object. The following code shows how to create a @Person@ prototype and use it to create new instance of @Person@.

<pre><code>var Person = {
	fullName: function() { return this.firstName + " " + this.lastName; }
};
Object.create(Person, {
	firstName: { 
		value: "Mads"
	}, 
	lastName: { 
		value: "Hartmann"
	} 
});</code></pre>

This approach allows for great flexibility and shows JavaScripts true prototypal nature. Unfortunately Object.create isn't implemented in all modern browsers and in the ones where it is implemented the Prototypal application isn't as performant as the Pseudoclassical one. Because of this I've chosen to use the Pseudoclassical approach in this library. 

h4. Comparisons

<table>
	<thead>
	<tr>
		<td></td>
		<td></td>
	</tr>
	</thead> 
	<tr>
		<td>Functional</td>
		<td></td>
	</tr>
	<tr>
		<td>Pseudoclassical</td>
		<td></td>
	</tr>
	<tr>
		<td>Prototypal</td>
		<td></td>
	</tr>
</table>

h3(#javascript_call_stack). Javascript call-stack

This section investigates the behavior of the call-stack of different javascript implementations. The following table shows the maximum depth of the call-stack in different browsers. Two measurements have been made: One using a recursive function and one using a tail-recursive function. The latter has been added to test if any of the javascript implementations did any  tail-recursive optimizations.

<table>
	<thead>
	<tr>
		<td> Browser </td>
		<td> Max depth of call-stack (recursive)</td>
		<td> Max depth of call-stack (tail-recursive)</td>
	</tr>
	</thead>
	<tr> 
		<td>Firefox (Version 3.6.13 on OS X)</td>
		<td>3000</td>
		<td>3000</td>
	</tr>
	<tr> 
		<td>Chrome (Version 10.0.648.127 on OS X)</td>
		<td>16379</td>
		<td>16381</td>
	</tr>
	<tr> 
		<td>Safari (Version 5.0.3 (6533.19.4) on OS X)</td>
		<td>52426</td>
		<td>47660</td>
	</tr>
</table>

These numbers show that none of the browsers support tail-recursive functions. This, unfortunately, means that tail-recursive functions have the possibility of breaking the application. This restricts how elegantly I've been able to implement the different data structures. For methods like map which are applied on every element in a collection I've been forced to rely on side-effects as a tail-recursive function would break the application when applied on collections with more than 3000 (in the case of Firefox) elements. 

Luckily this is an implementation detail and the API of the collections are still the same so if the javascript implementations should improve in the future it's possible for me to change the library implementation without introducing any breaking changes. 

The following is the program that has been used to measure the maximum depth of the call-stack using a recursive function. 

<pre>window.onload = function(){
	var globalCounter = 0,
		result;
	try {
		result = (function tailcall(){
			globalCounter++;
			return 1 + tailcall();
		})(globalCounter);
	} catch (e) {
		document.body.innerHTML = "Maximum call stack size: " + globalCounter;
		document.body.innerHTML = document.body.innerHTML + "<br />Result of function: " + result;
	}
};</pre>

The following is the program that has been used to see if the javascript implementation had support for tail-call optimization. 

<pre>window.onload = function(){
	var cnt = 0;
	try {
		(function tailcall(counter){
			cnt = counter+1;
			tailcall(cnt);
		})(cnt);
	} catch (e) {
		document.body.innerHTML = "Maximum call stack size: " + cnt;
	}
};</pre>

h2(#test). Test

Performance and unit tests. Show results 

h2(#conclusion). Conclusion

TODO

h2(#references). References

fn1. http://code.google.com/closure/

fn2. Speciale af Thomas Stjernegaard Jeppesen

fn3. http://jashkenas.github.com/coffee-script/

</div>