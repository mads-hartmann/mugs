---
title: Immutable Collections Library for Javascript: The Paper
---

<head>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<link rel="stylesheet" href="http://mads379.github.com/bachelorproject/css/screen.css" type="text/css" media="screen" title="no title" charset="utf-8">	
	<!-- <link rel="stylesheet" href="file:///Users/Mads/dev/projects/bachelorproject/css/screen.css" type="text/css" media="screen" title="no title" charset="utf-8"> -->
</head>


<h1 class="header">Immutable Collections Library for Javascript <br /> <em>The Paper</em></h1>
<ol id="menu">
	<li>"About":http://mads379.github.com/bachelorproject</li>
	<li>"The API":http://mads379.github.com/bachelorproject/api</li>
	<li>The Paper</li>
</ol>
<div id="container">

h2(#table_of_contents). Table of Contents 

# "Preface and introduction":#preface_and_introduction
# "Background and description of the problem":#background_and_description_of_the_problem
## "Problem Definition":#problem_definition
## "Design goals":#design_goals
## "Overview of collections":#overview_of_collections
## "Comparison with other collection libraries":#comparison_with_other_collections
## "Coffeescript":#coffeescript
# "Problem analysis":#problem_analysis
## "Equality and Comparison":#equality_and_comparison
## "Handling Exceptional States":#handling_exceptional_states
## "Implemented Data Structures":#implemented_data_structures
# "User’s guide and examples":#users_guide_and_examples
# "Technical description of the program":#technical_description_of_the_program
## "Javascript call-stack":#javascript_call_stack
## "Object construction":#object_construction
# "Test":#test
# "Conclusion":#conclusion
# "References":#references

h2(#preface_and_introduction). Preface and introduction

This report has been written by Mads Hartmann Jensen in the months February to May at the IT University of Copenhagen under the supervision of "Peter Sestoft":http://www.itu.dk/people/sestoft/.

During the project I developed an immutable collections library for Javascript written in the programming language Coffeescript.

h2(#background_and_description_of_the_problem). Background and description of the problem

h3(#problem_definition). Problem Definition

Javascript is a widely used programming language and it is used to implement countless of web applications. Despite of its popularity javascript has a very limited collections library which only contains one data-structure: An array which can function as a regular array, a stack, and a dictionary all at the same time. 
This has lead to the development of a range of open-source collection libraries such as Google Closure[1] and js_cols[2].

However, the current collection libraries available focus on mutable collections which are implemented using destructive updates. As such the goal of this project is to create a powerful set of immutable collection prototypes that will make it more natural to write javascript programs in a functional manner using features like higher-order functions. 

The library will be written in Coffeescript[3], a small language that compiles to JavaScript, as it adds a few semantics that will help simplify the code.

The project will include a set of performance tests that evaluate the data-structures on different implementations of javascript to make sure the performance of the data-structures are not subject to the implementation details of a specific javascript machine.

h3(#design_goals). Design goals

The overall goal is to create a powerful set of immutable collection prototypes for Javascript that promotes the use of functional javascript. The collection prototypes should feel natural to a developer coming from a functional programming language such as Scala.

The concrete goals of the project are:
# All the collection prototypes should be immutable.
# Provide a collection prototype library for Javascript that will feel natural to programmers coming from other functional programming languages.
# Provide an implementation of the most basic abstract data types (List, Set, Map, Queue).
# The code should be tested enough that potential users feel comfortable using the library.
# The collection library should be usable in the browser and server-side by, for example, NodeJS.
# To document the asymptotic run-time complexity of all implementations.

h3(#overview_of_collections). Overview of collections

Even though Javascript, being the dynamic language that it is, doesn't have interfaces I've made sure that there is a set of methods that are supported by all collection prototypes. Each collection must implement these methods and is free to add any additional methods specific to that abstract data types. 

The library contains an implementation of the following abstract data types:
# List 
# Set (TODO)
# Map (TODO)
# MultiMap (TODO)
# Stack (TODO)
# Queue (TODO)
# Random Access List (TODO)
# Priority Queue (TODO)

h3(#comparison_with_other_collections). Comparison with other collection libraries

This section will compare this library with the Google Closure Library and attempt to justify the creation of a new library.

The *Google Closure Library* is a comprehensive library that contains the implementation of of several data structures (AVL trees, Heaps, Maps, QuadTrees, Queues, Sets, TrieTrees and more). The library serves as the base Javascript library for many Google products, including: Gmail, Maps, Docs, Books and more. The library is open source and is actively being developed on by Google. Being used in production by Google also means that the library is well tested and well supported. 

However, all of the data structures in the Google Closure Library are mutable and their operations rely on destructive updates. There are currently no immutable collection libraries available for javascript that I'm aware of, hence the creation of this library. 

Ideally functional programs are side effect free, that means that functions can have no other effect than to compute their result. Programming with pure functions makes it a lot easier to reason about the state of your program. Having an immutable collections library makes it possible to keep your functions pure. 

The importance of immutability has also been established by Joshua Bloch in his book Effective Java as the 15th item "Minimize Mutability".

h3(#coffeescript). Coffeescript

Coffeescript is a small language that compiles to javascript. The output of the compiler is readable, pretty printed, javascript that passes the "Javascript Lint tool":http://www.javascriptlint.com/index.htm without warnings. Coffeescript is a dialect of Javascript with a simpler, more lightweight syntax. That is to say that it doesn't introduce any new concepts and it sticks to the original Javascript object model which uses prototypal inheritance. 

The two main reasons I've chosen to write this library in Coffeescript is that it has a nice syntax for function literals, which is important when you're writing your programs in a functional style, and is uses the convention that the last expression is used as the return value of a function. 

Here's a couple of Coffeescript examples and the resulting Javascript outputted by the compiler. The goal of these examples is to show the simplicity of Coffeescript and the readability of output. For a extensive description of the entire language, please go to the "Coffeescript homepage":http://jashkenas.github.com/coffee-script/ for more information

<table>
	<thead>
	<tr>
		<td width="40%">*Coffeescript*</td>
		<td width="40%">*Javascript*</td>
	</tr>
	</thead>
	<tr>
		<td><pre><code>(x,y) -> x+y</code></pre></td>
		<td><pre><code>(function(x, y) {    
  return x + y;    
});</code></pre></td>
	</tr>
	<tr>
		<td>
			<pre><code>Nil = () ->    
  this.head    = new None()    
  this.tail    = new None()    
  this.isEmpty = () -> true    
  this</code></pre>
		</td>
		<td><pre><code>var Nil;    
Nil = function() {    
  this.head = new None();    
  this.tail = new None();    
  this.isEmpty = function() {    
    return true;    
  };    
  return this;    
};</code></pre></td>
	</tr>
</table>

At the time of writing the version of Coffeescript is 1.0.1 and it is the version that's used in this report.

h2(#problem_analysis). Problem analysis

TODO

h3(#equality_and_comparison). Equality and comparison

TODO

h3(#handling_exceptional_states). Handling Exceptional States

*Spørgsmål: Skal jeg være mere beskrivende og forklare hvordan map, flatMap etc. er implementeret i Some og None så læseren kan se hvorfor man kan skrive vale.map( (a) -> b ).map( (b) -> c ).getOrElse(q) uden er beskymre sig om den første map er Some eller None?*

This section explains how the library deals with exceptional states. 

If the invocation of a method is not always guaranteed to be successful, for example a map lookup, it returns an instance of Option instead of throwing an exception. Instances of Option are either an instance of Some or None. Some is a single element container which contains the result of successfully executing the method. The use of the Option type is adopted from the Scala standard library.

The Option type returned from a method forces the developer to deal with the possibility of an error before it's possible to access the properties of the object. If exceptions were used the the developer would be free to ignore the possibility of an exception being thrown.

The most idiomatic way to deal with Option is to treat it as a collection and use the <code>map</code>, <code>flatMap</code>, <code>filter</code> and <code>foreach</code> methods. This allows the develop to chain operations on Option without having to check for the existence of a value before the very last expression where the developer can supply a fallback value using the <code>getOrElse()</code> method. See the example below:

<pre><code>persons = new Map({ 'key' : 'Mads', 'value' : 1234 })
details = new Map({ 'key' : 1234, 'value' : { 'address' : 'Grundtvigs Sidevej 1 st th' } })

address = persons.get("Mads")
                 .map( (id) -> details.get(id) )
                 .map( (obj) -> obj.address )
console.log(address.getOrElse("No address for user"))</code></pre>


h3(#implemented_data_structures). Implemented Data Structures

The following abstract data types have have been implemented: List, Set, Queue, Map, MultiMap, Stack. Some abstract data types have more than one implementation based on different data structures that offer different running time complexities of their operations. This allows the developer to pick the implementation that fits his/her needs. This section will describe each abstract data types and their implementations. 

Though the abstract data types are different in many ways they all support the same subset of operations. The most important operations are described below. For a full list of operations on each data type see the API documentation. 

In the following table the complexities are expressed in terms of n or n' where n is the size of the original collection and n' is the size of the resulting collection.

<table>
	<thead>
	<tr>
		<td width="140px">*Name*</td>
		<td>*Description*</td>
		<td width="50px">*Complexity*</td>
	</tr>
	</thead>
	<tr>
		<td>map( f )</td>
		<td>Applies the function 'f' on each element in the collection and returns a new collection with the values returned from applying the function 'f'.</td>
		<td>@O(N)@</td>
	</tr>
	<tr>
		<td>flatMap( f )</td>
		<td>Applies the function 'f' to all elements of the collection and concatenates the results.</td>
		<td>@O(n)@</td>
	</tr>
	<tr>
		<td>filter( f )</td>
		<td>Applies the function 'f' on each element and returns a collection of the same type with the elements where the function returned true.</td>
		<td>@O(n)@</td>
	</tr>
	<tr>
		<td>forEach( f )</td>
		<td>Applies the function f on each element in the collection and returns nothing. This means that forEach is invoked for the side effects of f.</td>
		<td>@O(n')@</td>
	</tr>
	<tr>
		<td>foldLeft( seed )( f )</td>
		<td>Applies the binary function 'f' on each element in the list starting from left. The function 'f' takes two arguments: The first is the accumulation of applying the function f on the elements of the collection so far. The second is the current value. </td>
		<td>@O(n)@</td>
	</tr>
</table>

h4(#list). List

Lists are ubiquitous in functional programming languages. A List contains a sequence of elements in the order they were inserted. A list consists of either Cons or Nil. Cons contains an element and a reference to the rest of the list. Nil represents the empty list. This is also sometimes known as a Singly-Linked-list.

The following operations are specific to the List abstract data type.

<table>
	<thead>
	<tr>
		<td width="140px">*Name*</td>
		<td>*Description*</td>
		<td width="50px">*Complexity*</td>
	</tr>
	</thead>
	<tr>
		<td>append( element )</td>
		<td>Create a new list by appending the element</td>
		<td>@O(n)@</td>
	</tr>
	<tr>
		<td>prepend( element )</td>
		<td>Create a new list by prepending the element</td>
		<td>@O(1)@</td>
	</tr>
	<tr>
		<td>update( index, element)</td>
		<td>Update the value with index 'index'. This will copy all values up to the given index.</td>
		<td>@O(n)@</td>
	</tr>
	<tr>
		<td>get( index )</td>
		<td>Get the element stored with the given index</td>
		<td>@O(n)@</td>
	</tr>
	<tr>
		<td>remove( index )</td>
		<td>Removes the element stored at the given index</td>
		<td>@O(n)@</td>
	</tr>
</table>
	

h4(#set). Set

Set contains a sequence of elements. The Set has the property that no element may appear twice. The library contains two implementations of Set: One based on a tree and one based on hashing.

h5(#tree_based_set). Tree Based Set

The TreeSet is implemented using a Red Black Tree which is a balanced tree with invariants to keep the height of the tree as low as possible. Here's the table of operations and their complexities supported by the tree-based set. 

<table>
	<thead>
	<tr>
		<td width="140px">*Name*</td>
		<td>*Description*</td>
		<td width="50px">*Complexity*</td>
	</tr>
	</thead>
	<tr>
		<td>insert( element )</td>
		<td>Adds the element to the set</td>
		<td>@O(log n)@</td>
	</tr>
	<tr>
		<td>update( index, element)</td>
		<td>Update the value with index 'index'. This will copy all values up to the given index.</td>
		<td>@O(log n)@</td>
	</tr>
	<tr>
		<td>get( index )</td>
		<td>Get the element stored with the given index</td>
		<td>@O(log n)@</td>
	</tr>
	<tr>
		<td>remove( index )</td>
		<td>Removes the element stored at the given index</td>
		<td>@O(log n)@</td>
	</tr>
</table>

h5(#hash_based_set). Hash Based Set

TODO

h4(#stack). Stack

A stack inserts and retrieves elements according to the last-in-first-out (LIFO) principle. The Stack Abstract Data Type has been implemented using a List because of it's quick access, insertion and removal of the first element. 

<table>
	<thead>
	<tr>
		<td width="140px">*Name*</td>
		<td>*Description*</td>
		<td width="50px">*Complexity*</td>
	</tr>
	</thead>
	<tr>
		<td>pop()</td>
		<td>Removes the top element form the stack</td>
		<td>@O(1)@</td>
	</tr>
	<tr>
		<td>push( element )</td>
		<td>Adds the 'element' to the top of the stack</td>
		<td>@O(1)@</td>
	</tr>
	<tr>
		<td>top()</td>
		<td>Returns the top element of the stack</td>
		<td>@O(1)@</td>
	</tr>
</table>

h4(#queue). Queue

A queue inserts and retrieves elements according to the first-in-first-out (FIFO) principle. The Queue Abstract Data Type has been implemented using a .... not sure yet ....

<table>
	<thead>
	<tr>
		<td width="140px">*Name*</td>
		<td>*Description*</td>
		<td width="50px">*Complexity*</td>
	</tr>
	</thead>
	<tr>
		<td>enqueue()</td>
		<td>Adds a new element to the queue</td>
		<td>@?@</td>
	</tr>
	<tr>
		<td>dequeue( element )</td>
		<td>Removes the next element in the queue</td>
		<td>@?@</td>
	</tr>
	<tr>
		<td>front()</td>
		<td>Returns the front-most element of the stack</td>
		<td>@?@</td>
	</tr>
</table>

h4(#map). Map 

A map stores elements according to a given key. The library contains two implementations of Map: One based on a tree and one based on hashing.

h5(#tree_based_map). Tree Based Map

The TreeMap is implemented using a Red Black Tree which is a balanced tree with invariants to keep the height of the tree as low as possible. Here's the table of operations and their complexities supported by the tree-based map. 

<table>
	<thead>
	<tr>
		<td width="140px">*Name*</td>
		<td>*Description*</td>
		<td width="50px">*Complexity*</td>
	</tr>
	</thead>
	<tr>
		<td>insert( key, value)</td>
		<td>Adds a new key/value pair to the map</td>
		<td>@O(log n)@</td>
	</tr>
	<tr>
		<td>get( key )</td>
		<td>Returns the element associated with the given key</td>
		<td>@O(log n)@</td>
	</tr>
	<tr>
		<td>remove( key )</td>
		<td>Removes the key/value pair from the map</td>
		<td>@O(log n)@</td>
	</tr>
	<tr>
		<td>contains( key )</td>
		<td>Checks if the map contains the given key</td>
		<td>@O(log n)@</td>
	</tr>
</table>

h5(#hash_based_map). Hash Based Map

TODO 

h4(#multi_map). Multi Map

TODO

h5(#tree_based_multimap). Tree Based Multi Map

TODO 

h2(#users_guide_and_examples). User’s guide and examples

Explain how to start using the library in the browser and NodeJS. Show some example programs and explain how they work.

If I have the time it would be cool to implement one or two of the problems in "Pearls of Functional algorithm design" or Exercise 12.8 in Algorithms and data structures - the basic toolbox 

h2(#technical_description_of_the_program). Technical description of the program

h3(#prototype_chain). Prototype chain 

<img src="images/prototype-chain.png" width="506" height="514" alt="Prototype Chain" />

h3(#javascript_call_stack). Javascript call-stack

All the implementations of javascript that I have tried have a fixed upper bound of the size of the call-stack. In firefox it's 3000, chrome 26.205 and Safari 52.427. Also javascript doesn't do tail-call optimizations. This restricts how "functional" it's possible to.

Instead of writing the map function on a list using the tail-recursive foldLeft method I instead use the forEach method and rely on side-effect to construct a new List with the mapped values. However, luckily this is an implementation detail and the API of the collections are still the same so if the javascript implementations should improve in the future it's possible for me to change the library implementation. 

h3(#object_construction). Object construction

There are many different ways to construct a new object in javascript and each one comes with its own set of merits and penalties. In this section I will introduce X different ways to construct objects in javascript and explain which one I've chosen for this library and why. 

h4(#factory_functions). factory function

In this approach you create a function .. 

<pre><code>var Class = function(){
	this.method = function(){};
}</code></pre>

The advantage of this approach is that you can define any variables you want inside of the function and they will act as private members. The disadvantage is that instances created with this method will be heavy objects in the sense that all of them will store the code for each method. 

h4(#prototype). Prototype 

<pre><code>var Class = function(){}
Class.prototype.method = function(){}</code></pre>

This resolves the disadvantage of the factory approach as all the instances share the same prototype object. This means that object creation is roughly 3 x faster (see section about performance tests) because the interpreter doesn't need to add the same methods to all of the objects and the objects takes up less memory. 

However, because the methods are no longer stored directly on the object the interpreter needs to do, at least, one extra lookup before it can execute the method. Because of this it takes roughly %40 longer to invoke a method on an object with this approach. With this approach it's not possible for the objects to have any private state. 

h2(#test). Test

Performance and unit tests. Show results 

h2(#conclusion). Conclusion

TODO

h2(#references). References

fn1. http://code.google.com/closure/

fn2. Speciale af Thomas Stjernegaard Jeppesen

fn3. http://jashkenas.github.com/coffee-script/

</div>